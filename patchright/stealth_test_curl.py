from curl_cffi import requests
import datetime
import sys
import os

# Get the absolute path of the parent directory
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(parent_dir)


# ==============================================================================
#  STEP 1: LOAD HEADERS FROM FILE (No longer launches a browser)
# ==============================================================================
def load_headers_from_file():
    """
    Imports the BASE_HEADERS dictionary from the generated base_headers.py file.
    """
    print("üìÇ STEP 1: Loading headers from './base_headers.py'...")
    try:
        # Dynamically import the headers from the file generated by the first script
        from base_headers import BASE_HEADERS

        print("‚úÖ Headers loaded successfully.")

        # We need to make sure the datadome cookie exists to run a valid test
        if "datadome" not in BASE_HEADERS.get("cookie", ""):
            print("‚ö†Ô∏è WARNING: 'datadome' cookie not found in the loaded headers.")
            print(
                "The test will run, but the results might not reflect a real authenticated session."
            )

        return BASE_HEADERS
    except ImportError:
        print("‚ùå ERROR: 'base_headers.py' not found.")
        print("Please run the header generation script first to create this file.")
        sys.exit(1)  # Exit the script if headers can't be loaded
    except Exception as e:
        print(f"‚ùå An unexpected error occurred while loading headers: {e}")
        sys.exit(1)


# ==============================================================================
#  STEP 1: DEFINE HEADERS (Simulating a real browser session)
# ==============================================================================
def get_sample_headers():
    """
    Provides a dictionary of headers similar to what a browser might send.
    Includes a placeholder for a Datadome cookie.
    """
    print("‚öôÔ∏è  STEP 1: Loading sample headers for the test...")
    # In a real scenario, these headers would be captured from a browser
    # or constructed based on a specific target.
    headers = {
        "sec-ch-ua": '"Not/A)Brand";v="99", "Google Chrome";v="120", "Chromium";v="120"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "upgrade-insecure-requests": "1",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "sec-fetch-site": "same-origin",
        "sec-fetch-mode": "navigate",
        "sec-fetch-user": "?1",
        "sec-fetch-dest": "document",
        "accept-encoding": "gzip, deflate, br",
        "accept-language": "en-US,en;q=0.9",
        "cookie": "datadome=A_VALID_DATADOME_COOKIE_WOULD_GO_HERE",  # Placeholder
    }
    print("‚úÖ Headers loaded.")
    return headers


# ==============================================================================
#  STEP 2: TEST FINGERPRINT (Using curl-cffi for impersonation)
# ==============================================================================
def test_request_fingerprint_with_curl(headers):
    """
    Sends the captured headers using curl-cffi to a fingerprinting service.
    The 'impersonate' parameter is key to defeating JA3 detection.
    """
    test_url = "https://tls.browserleaks.com/json"
    impersonation_target = "chrome120"
    print(
        f"\nüì° STEP 2: Testing request fingerprint with curl-cffi (impersonating {impersonation_target})..."
    )

    try:
        # We use curl_cffi's requests-like API
        response = requests.get(
            test_url,
            headers=headers,
            impersonate=impersonation_target,  # This is the magic that sets a browser-like TLS signature
            timeout=20,
        )

        if response.status_code == 200:
            fingerprint_data = response.json()
            print("‚úÖ Analysis successful.")

            # Since we are impersonating Chrome, the verdict should be positive.
            verdict = "Success: The JA3 fingerprint likely matches a real Chrome browser due to curl-cffi impersonation."
            return fingerprint_data, verdict
        else:
            print(f"‚ùå Test failed. Status code: {response.status_code}")
            return None, "Test Failed: Received a non-200 status code."

    except Exception as e:
        print(f"‚ùå An error occurred during the curl-cffi request: {e}")
        return None, f"Test Error: {e}"


# ==============================================================================
#  STEP 3: GENERATE REPORT (The final output)
# ==============================================================================
def generate_report(headers, fingerprint_data, verdict):
    """
    Formats the collected data into a report and saves it to a text file.
    """
    print("\nüìÑ STEP 3: Generating final results report...")

    # Ensure fingerprint_data is a dictionary to prevent errors on .get()
    if not isinstance(fingerprint_data, dict):
        fingerprint_data = {}
        print("‚ö†Ô∏è  Warning: Fingerprint data is missing. Report will have N/A values.")

    user_agent = headers.get("user-agent", "Not found")
    ja3_hash = fingerprint_data.get("ja3_hash", "N/A")
    http2_fp = fingerprint_data.get("http2_fp", "N/A")

    report_content = f"""
# ==================================================
#  Request Fingerprint Analysis Report
# ==================================================
#
#  Date & Time: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
#  Test Client: curl-cffi (impersonating chrome120)
#
# --------------------------------------------------
#  1. SESSION CONTEXT
# --------------------------------------------------
#
#  User-Agent Sent: {user_agent}
#  Datadome Cookie: {"Obtained and sent successfully." if "datadome" in headers.get('cookie', '') else "Not found."}
#  Total Headers Sent: {len(headers)}
#
# --------------------------------------------------
#  2. FINGERPRINT ANALYSIS
# --------------------------------------------------
#
#  TLS (JA3) Hash: {ja3_hash}
#  HTTP/2 Fingerprint: {http2_fp}
#
# --------------------------------------------------
#  3. CONCLUSION
# --------------------------------------------------
#
#  Verdict: {verdict}
#
#  Explanation: The test was performed using curl-cffi, which masks the
#  default Python TLS signature and impersonates a real web browser. This
#  new JA3 hash should match that of Chrome, defeating TLS fingerprinting.
#
# ==================================================
"""
    try:
        with open("final_fingerprint_report.txt", "w", encoding="utf-8") as f:
            f.write(report_content.strip())
        print("‚úÖ Report saved successfully to 'final_fingerprint_report.txt'")
    except Exception as e:
        print(f"‚ùå Failed to save report: {e}")


# ==============================================================================
#  MAIN EXECUTION
# ==============================================================================
def main():
    """
    Main function to run the fingerprinting test and generate a report.
    """
    # Step 1: Get headers
    headers = load_headers_from_file()

    # Step 2: Test the fingerprint using curl-cffi
    fingerprint_data, verdict = test_request_fingerprint_with_curl(headers)

    # Step 3: Generate the final report if the test was successful
    if fingerprint_data:
        generate_report(headers, fingerprint_data, verdict)
    else:
        print("\nCould not generate a report because the fingerprint test failed.")


if __name__ == "__main__":
    main()
